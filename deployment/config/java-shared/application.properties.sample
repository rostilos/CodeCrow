# App Properties
codecrow.security.jwtSecret=BOipcCYbZXW0XBzS9YPzBY7ylc2iRZ94CUybbz4F6Kc=
codecrow.security.jwtExpirationMs=86400000
#7 days for refresh token
codecrow.security.refreshTokenExpirationMs=604800000

#3 months - default value
codecrow.security.projectJwtExpirationMs=7776000000
#Old key if was rotated
codecrow.security.encryption-key-old=wd6CUSAcZIenXXUOeXhgPozSk3w6wCWymh/N5/J5Bho=
codecrow.security.encryption-key=wd6CUSAcZIenXXUOeXhgPozSk3w6wCWymh/N5/J5Bho=

# Internal API secret for service-to-service communication (mcp-client to web-server)
# Must match INTERNAL_API_SECRET env var in mcp-client container
codecrow.internal.api.secret=${CODECROW_INTERNAL_API_SECRET:change-this-secret-in-production}

# Application name (used in emails and 2FA setup)
codecrow.app.name=CodeCrow

#WEB SERVER URL (API server - used for OAuth callbacks)
codecrow.web.base.url=http://localhost:8081

# Frontend URL (for redirects after OAuth)
codecrow.frontend-url=http://localhost:8080

# ============================================================================
# EMAIL / SMTP CONFIGURATION
# ============================================================================
# IMPORTANT: Configure these settings to enable email functionality
# including 2FA email verification, notifications, and password reset.
#
# For production, use a reliable SMTP provider:
# - Amazon SES (recommended for AWS deployments)
# - SendGrid (easy setup, good deliverability)
# - Mailgun (developer-friendly)
# - Gmail SMTP (for testing only, has daily limits)
# - Microsoft 365 / Office 365
# - Your own mail server (requires proper SPF/DKIM/DMARC setup)
#
# ============================================================================

# Enable/disable email sending (set to false for development without SMTP)
codecrow.email.enabled=true

# Sender email address and display name
codecrow.email.from=noreply@codecrow.io
codecrow.email.from-name=CodeCrow

# Application name used in email templates
codecrow.email.app-name=CodeCrow

# Frontend URL for links in emails (should match codecrow.frontend-url)
codecrow.email.frontend-url=http://localhost:8080

# SMTP Server Configuration
# Replace these placeholders with your actual SMTP credentials
spring.mail.host=<SMTP_HOST>
spring.mail.port=587
spring.mail.username=<SMTP_USERNAME>
spring.mail.password=<SMTP_PASSWORD>

# SMTP Properties
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true
spring.mail.properties.mail.smtp.connectiontimeout=5000
spring.mail.properties.mail.smtp.timeout=5000
spring.mail.properties.mail.smtp.writetimeout=5000

# ============================================================================
# SMTP PROVIDER EXAMPLES (uncomment and configure the one you use):
# ============================================================================

# --- GMAIL SMTP (Testing only - 500 emails/day limit) ---
# spring.mail.host=smtp.gmail.com
# spring.mail.port=587
# spring.mail.username=your-email@gmail.com
# spring.mail.password=your-app-password
# NOTE: Use App Password, not your regular password. Enable 2FA first:
# https://myaccount.google.com/apppasswords

# --- AMAZON SES ---
# spring.mail.host=email-smtp.us-east-1.amazonaws.com
# spring.mail.port=587
# spring.mail.username=<AWS_SES_SMTP_USERNAME>
# spring.mail.password=<AWS_SES_SMTP_PASSWORD>
# NOTE: Verify your domain and sender email in SES console first

# --- SENDGRID ---
# spring.mail.host=smtp.sendgrid.net
# spring.mail.port=587
# spring.mail.username=apikey
# spring.mail.password=<SENDGRID_API_KEY>

# --- MAILGUN ---
# spring.mail.host=smtp.mailgun.org
# spring.mail.port=587
# spring.mail.username=postmaster@your-domain.mailgun.org
# spring.mail.password=<MAILGUN_SMTP_PASSWORD>

# --- OFFICE 365 / MICROSOFT 365 ---
# spring.mail.host=smtp.office365.com
# spring.mail.port=587
# spring.mail.username=your-email@your-domain.com
# spring.mail.password=<YOUR_PASSWORD>

# ============================================================================

# ============================================================================
# Bitbucket Cloud OAuth Consumer Configuration (for user-based integration)
# ============================================================================
# Create an OAuth consumer in Bitbucket workspace settings:
# 1. Go to Bitbucket Settings -> Workspace settings -> OAuth consumers -> Add consumer
# 2. Name: CodeCrow
# 3. Callback URL: ${codecrow.web.base.url}/api/{workspaceSlug}/integrations/bitbucket-cloud/app/callback
# 4. Permissions: Account (Read), Repositories (Read, Write), Pull Requests (Read, Write), Webhooks (Read, Write)
# 5. Copy the Key (client-id) and Secret (client-secret) below
codecrow.bitbucket.app.client-id=
codecrow.bitbucket.app.client-secret=

# ============================================================================
# Bitbucket Connect App Configuration (for workspace-based integration / SaaS)
# ============================================================================
# This is for creating a Bitbucket Connect App that can be installed at the workspace level.
# See /bitbucket-app/README.md for setup instructions.
#
# 1. Register the Connect App descriptor URL in Bitbucket:
#    - Go to Bitbucket Settings -> Workspace settings -> Develop apps
#    - Add descriptor URL: https://your-domain.com/api/bitbucket/connect/descriptor
# 2. The OAuth credentials are obtained when the app is installed.
#    For development, you can use the same credentials as the OAuth consumer above.
codecrow.bitbucket.connect.client-id=
codecrow.bitbucket.connect.client-secret=



# ============================================================================
# GitHub App Configuration (for SaaS integration)
# ============================================================================
# 1. Create a GitHub App at https://github.com/settings/apps/new
# - Set the callback URL to: https://server.rostilos.pp.ua/api/integrations/github/app/callback
# - Set required permissions (Contents: Read, Pull requests: Read/Write, etc.)
# - Generate and download the private key (.pem file)
# 2.Configure the app in application.properties:
# codecrow.github.app.id=YOUR_APP_ID
# codecrow.github.app.slug=your-app-slug
# codecrow.github.app.private-key-path=/app/config/github-app-private-key.pem
# 3. Mount the private key in the Docker container (add to docker-compose.yml volumes)
# 4. Users can now install the app on their accounts/organizations to grant access to private repositories
#
# Required OAuth Scopes (requested during authorization):
# - repo: Full control of private repositories
# - read:user: Read user profile data
# - read:org: Read organization membership
# ============================================================================
codecrow.github.app.id= The GitHub App ID
codecrow.github.app.slug= - The URL-friendly app name (e.g., "codecrow")
codecrow.github.app.private-key-path= - Path to the private key .pem file
codecrow.github.app.webhook-secret= - Webhook secret for verification

# Google OAuth Configuration (for social login)
# Create OAuth 2.0 Client ID in Google Cloud Console:
# 1. Go to https://console.cloud.google.com/apis/credentials
# 2. Create OAuth 2.0 Client ID (Web application)
# 3. Add authorized JavaScript origins: your frontend URL (e.g., http://localhost:8080)
# 4. Add authorized redirect URIs: your frontend URL (e.g., http://localhost:8080)
# 5. Copy the Client ID below
codecrow.oauth.google.client-id=

# Webhook base URL (if different from codecrow.base-url, for pipeline agent webhooks)
codecrow.webhook.base-url=http://localhost:8082

#MCP CLIENT URL
codecrow.mcp.client.url=http://host.docker.internal:8000/review

#RAG
codecrow.rag.api.url=http://host.docker.internal:8001
codecrow.rag.api.enabled=true
# RAG API timeouts (in seconds)
codecrow.rag.api.timeout.connect=30
codecrow.rag.api.timeout.read=120
# RAG indexing timeout - 4 hours for large repositories
codecrow.rag.api.timeout.indexing=14400

# Analysis Lock Configuration
# Lock timeout - maximum time for a single analysis to hold a lock (in minutes)
analysis.lock.timeout.minutes=30
# RAG indexing lock timeout - longer timeout for RAG indexing operations (in minutes, default 6 hours)
analysis.lock.rag.timeout.minutes=360
# Lock wait timeout - maximum time to wait for a lock to be released (in minutes)
analysis.lock.wait.timeout.minutes=5
# Lock retry interval - time to wait between lock acquisition retries (in seconds)
analysis.lock.wait.retry.interval.seconds=5
# Lock cleanup interval - how often to clean up expired locks (in milliseconds)
analysis.lock.cleanup.interval.ms=300000

springdoc.swagger-ui.operationsSorter=method
springdoc.swagger-ui.path=/swagger-ui-custom.html
springdoc.api-docs.path=/api-docs

spring.servlet.multipart.max-file-size=500MB
spring.servlet.multipart.max-request-size=500MB

spring.mvc.async.request-timeout = -1

# Logging configuration
logging.level.org.springframework.security.web.access.ExceptionTranslationFilter=ERROR
logging.level.org.apache.catalina.core.ApplicationDispatcher=ERROR
logging.level.org.apache.catalina.core.StandardHostValve=ERROR

# Completely disable Hibernate SQL output
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.show_sql=false
spring.jpa.properties.hibernate.format_sql=false
spring.jpa.properties.hibernate.use_sql_comments=false
logging.level.org.hibernate=ERROR
logging.level.org.hibernate.SQL=OFF
logging.level.org.hibernate.type=OFF
logging.level.org.hibernate.type.descriptor.sql=OFF
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=OFF
logging.level.org.hibernate.orm.jdbc.bind=OFF